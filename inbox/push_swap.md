# Mendetory
Makefile, \*.h, \*.c
read, write, malloc, free, exit ft_printf and any equivalent YOU coded
스택 a에 있는 인자들을 스택 b를 이용해 정렬하기

## 공부할 것
1. 알고리즘 / 시간복잡도
2. 각 알고리즘

## 코드 구성
1. 입력값 처리
	문자로 들어오는 것들 분리, 숫자로 바꾸고, 자료구조에 삽입.
2. 자료구조 구상 및 구현
	배열 혹은 연결리스트  > 각자의 알고리즘에 따라서.
3. 11가지 operatror 구현
4. 알고리즘 구상 밎 구현

## 알고리즘
1.  [quick sort](https://eeeuns.github.io/files/quick_sort.html#pf21)
	분할 정복 / 비균등 분할 [설명](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html) 
	분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
	배열은 여러 크기.
2. merge sort
	하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법..
	배열은 항상 반으로.
3. greedy
	미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법
4. radix sort
	**기수정렬은 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘입니다.** 기수정렬은 비교 연산을 하지 않으며 정렬 속도가 빠르지만 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 더 필요합니다. >>
	낮은 자릿수 - 높은 자릿수 순으로 정렬. 
5.

# 구현
모든 정렬을 실행해 본 다음에 가장 빠른 정렬 식을 실제로 실행한다면 어떨까?
그렇다면 실제로 두번씩 실행하는 게 나을까 아니면 한번 실행한 후 결과값을 저장하고 그 결과값대로 출력만 하는 게 나을까. 

## 기수정렬
기본  기수 정렬 : a를 1으로, b를 0로 두고 기수를 올려가면서 정렬
조금 더 정렬 : 기수를 2개씩 보면서 앞 기수가 1이면 a, 0이면 b에 넣되
뒷 기수가 1이면 위, 0이면 아래 


